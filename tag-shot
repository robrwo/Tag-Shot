#!/usr/bin/perl

=head1 NAME

tag-shot - add tags to Shotwell photos

=head1 SYNOPSIS

=cut

package Shotwell::DB;

use strict;
use warnings;

use Carp;
use DBI;
use DBD::SQLite;
use File::Copy;
use File::HomeDir;
use File::Spec;
use Scalar::Util qw( refaddr );

use self;

my %Db_File	= ( ); # database files
my %Dbh		= ( ); # database handles

my %Sth_Photos	= ( ); # for looking up photo info
my %Sth_Tags	= ( ); # for looking up tags

my %File_Ids	= ( ); # filename -> id

my %Tag_Ids	= ( ); # tag -> id
my %Tag_Photos  = ( ); # tag -> array of photo-ids

sub default_db_file {
    return File::Spec->catfile(
	File::HomeDir->my_home,
	".shotwell/data/photo.db"
    );
}

sub connect {
    my $class = shift || __PACKAGE__;

    my $this = { };

    bless $this, $class;

    my $file = shift @args || default_db_file();

    if (-e $file) {

	$Db_File{refaddr $this} = $file;

	copy($file, $file . ".backup");

	$Dbh{refaddr $this} = DBI->connect("dbi:SQLite:dbname=${file}", "", "")
	    or croak("Unable to connect to database '${file}': ", DBI->errstr);

	return $this;
    }
    else {
	croak("Cannot find database file '${file}'");
	return;
    }
}

sub disconnect {
    $Sth_Photos{refaddr $self}->finish(),
       if (exists $Sth_Photos{refaddr $self});

    $Sth_Tags{refaddr $self}->finish(),
      if (exists $Sth_Tags{refaddr $self});

    $Dbh{refaddr $self}->disconnect();
}


sub photo_id {
    my $file = shift @args;

    # Normalise filename

    unless (File::Spec->file_name_is_absolute($file)) {
	$file = File::Spec->rel2abs($file);
    }

    # Check if it's been fetched already

    if (exists $File_Ids{$file}) {
	return $File_Ids{$file}
    }

    # Initialise the statement handle

    unless (exists $Sth_Photos{refaddr $self}) {
	$Sth_Photos{refaddr $self} = $Dbh{refaddr $self}->prepare(
	    "SELECT id FROM PhotoTable WHERE filename=? LIMIT 1"
	    ) or croak("Unable to prepare SQL statement: ",
		       $Dbh{refaddr $self}->errstr);
    }

    # Lookup the id

    if (-e $file) {

	$Sth_Photos{refaddr $self}->execute($file);
	if (my $row = $Sth_Photos{refaddr $self}->fetchrow_hashref) {
	   return $File_Ids{$file} = $row->{id};
	}
	else {
	    return 0;
	}
    }
    else {
	carp("Cannot find file '${file}'\n");
    }
}

sub tag_id {
    my $tag = shift @args;

    # Check if it's been fetched already

    if (exists $Tag_Ids{$tag}) {
	return $Tag_Ids{$tag}
    }

    # Initialise the statement handle

    unless (exists $Sth_Tags{refaddr $self}) {
	$Sth_Tags{refaddr $self} = $Dbh{refaddr $self}->prepare(
	    "SELECT id, photo_id_list FROM TagTable WHERE name=? LIMIT 1"
	    ) or croak("Unable to prepare SQL statement: ",
		       $Dbh{refaddr $self}->errstr);
    }

    # Lookup the id

    $Sth_Tags{refaddr $self}->execute($tag);
    if (my $row = $Sth_Tags{refaddr $self}->fetchrow_hashref) {
	my $id = $row->{id};
	$Tag_Photos{$tag} = [ split /,/, ($row->{photo_id_list} || "") ];
	return $Tag_Ids{$tag} = $id;
    }
    else {
	return 0;
    }
}

sub add_photo_ids_to_tag {
    my $tag = shift @args;

    unless (exists $Tag_Photos{$tag}) {
	$Tag_Photos{$tag} = [ ];
    }

    my %merge = map { $_ => 1 } (@{ $Tag_Photos{$tag} }, @args);

    $Tag_Photos{$tag} = [ grep $_, keys %merge ];
}

sub add_photos_to_tag {
    my $tag = shift @args;

    $self->add_photo_ids_to_tag($tag,
				map { $File_Ids{$_} || 0 } @args);
}

sub save_tags {
    my $add = shift @args; # add new tags?

    my $sth_update = $Dbh{refaddr $self}->prepare(
	"UPDATE TagTable SET photo_id_list=? WHERE id=?"
	) or croak("Unable to prepare SQL statement: ",
		   $Dbh{refaddr $self}->errstr);

    my $sth_add = $Dbh{refaddr $self}->prepare(
	"INSERT INTO TagTable (name, photo_id_list, time_created) VALUES (?, ?, ?)"
	) or croak("Unable to prepare SQL statement: ",
		   $Dbh{refaddr $self}->errstr);

    foreach my $tag (keys %Tag_Photos) {

	my $photo_ids = join(",", @{$Tag_Photos{$tag}});

	if ($photo_ids) {
	    if (exists $Tag_Ids{$tag}) {

		my $id = $Tag_Ids{$tag};
		$sth_update->execute($photo_ids, $id);

	    } elsif ($add) {
		$sth_add->execute($tag, $photo_ids, time());
		$Tag_Ids{$tag} = $Dbh{refaddr $self}->func('last_insert_rowid');
	    }
	}
	else {
	    carp("No photos associated with tag '${tag}': ignoring.\n");
	}
    }

    $sth_update->finish();
    $sth_add->finish();
}

package main;

use strict;
use warnings;

use Carp;
use Getopt::Long;
use Geo::Coordinates::Transform;
# use Geo::GeoNames;
use Image::ExifTool;
use JSON;
use LWP::Simple;

my $Db_File = undef;

my $Verbose    = 1;
my $AddNewTags = 1;
my $GeoTag     = 0;

my @Files = ( );
my @Tags  = ( );

my $res = GetOptions(

    'd|database=s'	=> \$Db_File,

    'v|verbose!'        => \$Verbose,

    'add-new-tags!' 	=> \$AddNewTags,

    'g|geo!'              => \$GeoTag,

    't|tags=s'		=> sub {
	my ($field, $tags) = @_;
	foreach my $tag (split /,/, $tags) {
	    if ($tag =~ /^([\'\"])(.*)([\'\"])$/) {
		$tag = $2, if ($1 eq $3);
	    }
	    push @Tags, $tag;
	}
      },

    '<>'		=> sub {
	push @Files, shift;
      },

    );

unless ($res) {
    exit 1;
}

my $db = Shotwell::DB->connect($Db_File);

my $exif = new Image::ExifTool;

foreach my $file (@Files) {
    my $id = $db->photo_id($file);
    if ($id) {

	print "${file}: ", if ($Verbose);

	if ($GeoTag) {

	    my $info = $exif->ImageInfo("$file");
	    my $coords = get_coords($info);
	    if ($coords) {

		my @toponyms = get_toponyms($coords);

		print join(",", @toponyms), "\n";

		foreach my $name (@toponyms) {
		    $db->tag_id($name);                    # load tag info
		    $db->add_photo_ids_to_tag($name, $id);
		}

	    }

	}

	print "\n", if ($Verbose);

    }
    else {
	carp("File '${file}' not found in the database.\n");
    }
}

foreach my $tag (@Tags) {
    my $id = $db->tag_id($tag);
    $db->add_photos_to_tag($tag, @Files);
}

$db->save_tags($AddNewTags);

$db->disconnect();

exit 0;

# Fetch GPS coordinates from ImageInfo, and convert them to decimal degrees

sub get_coords {
    my $info = shift;

    my $latx  = $info->{GPSLatitude};
    my $lonx  = $info->{GPSLongitude};

    if ($latx && $lonx) {

	$latx =~ /^(\d+) deg (\d+)\' (\d+\.\d+)\" ([NS])$/;
	my @lat = ( ($4 eq 'S') ? -$1 : $1, $2, $3);

	$lonx =~ /^(\d+) deg (\d+)\' (\d+\.\d+)\" ([WE])$/;
	my @lon = ( ($4 eq 'W') ? -$1 : $1, $2, $3);

	my $cnv = new Geo::Coordinates::Transform;

	return $cnv->cnv_to_dd( [ "@lat", "@lon" ] );
    } else {
	return;
    }
}

#

my %Cache = ( );

sub toponym_query {
    my $coords = shift;
    my $userid = shift;
    my $url    = sprintf("http://ws.geonames.org/findNearbyPlaceNameJSON?lat=%f\&lng=%f", @$coords);
    if ($userid) {
	$url .= "&username=${userid}";
    }

    # print "${url}\n";

    if (exists $Cache{$url}) {
	return $Cache{$url};
    } else {
	return $Cache{$url} = get($url);
    }
}

sub get_toponyms {
    my $coords = shift;
    my $userid = shift;

    my $json   = toponym_query($coords, $userid);
    if ($json) {
	my $data   = decode_json($json);

	my %tags   = ( );
	foreach my $d (@{$data->{geonames}}) {

	    foreach my $k (qw(name toponymName countryName adminName1 adminName2 adminName3 )) {
		if (($d->{$k}||"") ne "") {
		    $tags{$d->{$k}} = 1;
		}
	    }

	}
	return (keys %tags);
    }
    else {
	return;
    }

    # eval {
    #
    # 	my $geo = new Geo::GeoNames();
    #
    # 	# This is buggy and often crashes
    #
    # 	my $res = $geo->find_nearby_placename(
    # 	    lat => $coords->[0],
    # 	    lng => $coords->[1]
    # 	);
    #
    # 	# It also does not return as much information
    #
    # 	return ($res->{name}, $res->{countryName});
    #
    # };

    # return;
}


